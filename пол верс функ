//
// Created by Lenovo on 29.10.2025.
//

#ifndef FUNCTION_PROJECT_1_STUDENT_1_H
#define FUNCTION_PROJECT_1_STUDENT_1_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_LENGTH_OF_NUMBER 13
#define MAX_LENGTH_OF_FRACTIONAL_PART 12
int ChekInput();
int ValidateBase(int);
int CharToValue(char);
char ValueToChar(int);
char* AcceptableSymbols(int);
int ValidateNumber(char *, int, int);
void SplitNumberString(char* , char*,char*);
int IntStringToDecimal(char*, int);
double FracStringToDecimal(char*, int, int);
double StringToDecimal(char*, int);
char* IntDecimalToString(int, int);
char* FloatDecimalToString(double, int);
char* DecimalToString(double, int);

#endif


/* Checks that there are no more characters after the number entered. */
int inline ChekInput() {
    int nextchar;
    while ((nextchar = getchar()) == ' ');
    if (nextchar != '\n')
        return 0;
    return 1;

}

/*checks the validity of the number system*/
int inline ValidateBase(int base) {
    if (base >= 2 && base <= 16)
        return 1;
    return 0;
}

/* Returns the numeric value of a character using the ASCII table. */
int inline CharToValue(char c) {
    if (c >= '0' && c <= '9')
        return c - '0';

    if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;

    if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
}

/* Returns the character designation of a number using the ASCII table. */
char inline ValueToChar(int value) {
    if (value >= 0 && value <= 9)
        return (char)('0' + value);

    return (char)('a' + (value - 10));
}


/* Returns a list of characters that are valid in the given number system. */
char inline *AcceptableSymbols(int base) {
    int lenlist;
    if (base <= 10)
        lenlist = base + 1;
    else
        lenlist = base + (base - 10) + 1;

    char *listofcharacters = malloc((lenlist + 1) * sizeof(char)); //проверка выделения памяти///

    if (listofcharacters == NULL)
        return NULL;

    int capitalletters = 0;
    for (int i = 0; i < base; i++) {
        *(listofcharacters + i) = ValueToChar(i);
        if (i >= 10) {
            capitalletters++;
            *(listofcharacters + lenlist - 1 - capitalletters) = (char)('A' + (i - 10));
        }
        }

        *(listofcharacters + lenlist - 1) = '.';
        *(listofcharacters + lenlist) = '\0';

        return listofcharacters;
    }

/* checks that all characters in the number satisfy the given number system
 * and that there are no leading zeros, dots at the beginning and end of the
 * number, or more than one dot*/
int inline ValidateNumber(char *number, int base, int len) {
    char *list = AcceptableSymbols(base);

    if (*number == '.' || *(number + len - 1) == '.') {
        free(list);
        return 0;
    }
    int point = 0;

    for (int i = 0; i < len; i++)
        if (*(number + i) == '.') {
            point++;
            if (point > 1) {
                free(list);
                return 0;
            }
        }

    for (int i = 0; i < len; i++) {
        int validcharacter = 0;

        for (int j = 0; *(list + j) != '\0'; j++)
            if (*(number + i) == *(list + j)) {
                validcharacter = 1;
                break;
            }

        if (validcharacter == 0) {
            free(list);
            return 0;
        }
    }
    if (point == 0 && *number == '0' && len != 1){
    free(list);
    return 0;
}
    if (point == 1 && *number == '0' && *(number + 1) == '0') {
        free(list);
        return 0;
    }
    free(list);
    return 1;
}

/*Splits a string number into its integer and fractional parts.*/
void inline SplitNumberString(char* number, char* integerpart, char* fractionalpart) {

    int pointindex = 0;

    for (int i = 0; number[i] != '\0'; i++) {
        if (number[i] == '.') {
            pointindex = i;
            break;
        }
    }
    /* If there is no dot in the number,copies the integer part and
     * leaves the fractional part empty.*/
    if (pointindex == 0) {
        strcpy(integerpart, number);
        *fractionalpart = '\0';
    }
    else {
        /* copies the integer part*/
        strncpy(integerpart, number, pointindex);
        *(integerpart + pointindex) = '\0';

        /* copies the fractional part*/
        strcpy(fractionalpart, number + pointindex + 1);
    }
}

/* Converts an integer part from a certain number system to decimal using
 * the Gorner algorithm */
int inline IntStringToDecimal(char* integerpart, int base) {
    int result = 0;
    for (int i = 0; *(integerpart + i) != '\0'; i++)
        result = result * base + CharToValue(*(integerpart + i));
    return result;
}

/* Converts a fractional part from a certain number system to decimal */
double inline FracStringToDecimal(char* fractionalpart, int base, int len) {
    double result = 0;
    for (int i = len - 1; i >= 0; i--)
        result = (result + CharToValue(*(fractionalpart + i))) / base;
    return result;
}

/*converts the integer and fractional parts of a number to the decimal system
 *and sums the results*/
double inline StringToDecimal(char* number, int base) {
    char* integerpart = malloc( (MAX_LENGTH_OF_NUMBER + 1) * sizeof(char)); //проверка выделения памяти
    if (integerpart == NULL)////////сделать нормальную проверку
        return 0;

    char* fractionalpart = malloc( (MAX_LENGTH_OF_FRACTIONAL_PART + 1) * sizeof(char)); //проверка выделения памяти
    if (fractionalpart == NULL) {///////////сделать нормальную проверку
        free(integerpart);
        return 0;
    }

    SplitNumberString(number, integerpart, fractionalpart);

    double result = IntStringToDecimal(integerpart, base) + FracStringToDecimal(fractionalpart, base, (int)strlen(fractionalpart));

    free(integerpart);
    free(fractionalpart);

    return result;
}
/* Converts an integer from decimal to a certain number system. */
char inline * IntDecimalToString(int number, int base) {
    if (number == 0) {
        char *res = malloc(2 * sizeof(char)); //проверка выделения памяти
        *res = '0';
        *(res + 1) = '\0';
        return res;
    }

    int lenres = 0;
    int copynum = number;

    /* Defines the length of the converted number. */
    while (copynum > 0) {
        lenres++;
        copynum /= base;
    }

    char *res = malloc((lenres + 1)  * sizeof(char)); //проверка выделения памяти
    *(res + lenres) = '\0';

    /* Fills an array with characters in reverse order. */
    int i = lenres - 1;
    while (number > 0) {
        char character = ValueToChar(number % base);
        *(res + i) = character;
        number /= base;
        i--;
    }

    return res;
}

/* Converts the fractional part of a number from decimal to a certain number
 * system. Multiplies the fractional part by the base of the number system.
 * The character designation of the integer part of the resulting number
 * is the first digit after the decimal point of the converted number.
 * The fractional remainder is then converted in a similar manner. */
char inline *FloatDecimalToString(double number, int base) {
    int singsafterdot = 0;
    char *res = malloc((MAX_LENGTH_OF_NUMBER + 1) * sizeof(char)); //проверка выделения памяти

    /* Needs to get the first 12 digits after decimal point */
    while (singsafterdot < MAX_LENGTH_OF_FRACTIONAL_PART) {
        char character = ValueToChar((int)(number * base));
        *(res + singsafterdot) = character;

        singsafterdot ++;
        number = (number * base) - (int)(number * base);

        /* Returns the result earlier if there are fewer than 12 digits after
         * the decimal point.*/
        if (number == (int)number) {
            *(res + singsafterdot) = '\0';
            return res;
        }
    }
    *(res + singsafterdot) = '\0';
    return res;
}

/*Converts a number from the decimal number system to the finite number system*/
char inline *DecimalToString(double num, int base) {

    /*If the number does not contain a fractional part, simply convert it.*/
    if (num == (int)num) {
        char* result = IntDecimalToString((int)num, base);
        return result;
    }

    /* If there is a fractional part, it converts the whole and fractional parts
     * separately and combines the results*/
    int integerpart = (int)num;
    double fractionalpart = num - integerpart;

    char* convintpart = IntDecimalToString(integerpart, base);
    char* convfracpart = FloatDecimalToString(fractionalpart, base);

    int lenres = strlen(convintpart) + strlen(convfracpart) + 2;
    char* result = malloc(lenres * sizeof(char)); //проверка выделения памяти

    int pointindex = 0;
    for (int i = 0; i < strlen(convintpart); i++) {
        *(result + i) = *(convintpart + i);
        pointindex = i + 1;
    }

    *(result + pointindex) = '.';
    int j = 0;
    for (int i = pointindex + 1; i <= pointindex + strlen(convfracpart); i++) {
        *(result + i) = *(convfracpart + j);
        j++;
    }

    *(result + lenres - 1) = '\0';

    free(convfracpart);
    free(convintpart);

    return result;
}




