//
// Created by Lenovo on 26.10.2025.
//

#ifndef STUDENT1_H
#define STUDENT1_H
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int ValideteBase(int);
char ValueToChar(int);
int CharToValue(char);
char* AcceptableSymbols(int);
int ValideteNumber(const char *, int, int);
void SplitNumberString(const char* , char*,char*);
int IntStringToDecimal(const char*, int);
double FracStringToDecimal(const char*, int, int);
double StringToDecimal(const char*, int);
char* IntDecimalToString(int, int);
char* FloatDecimalToString(double, int);
char* DecimalToString(double, int);
#endif

int ValideteBase(int base) {
    if (base >= 2 && base <= 16 )
        return 1;
    return 0;
}
/* Returns the numeric value of a character using the ASCII table. */
int CharToValue(char c) {
    if (c >= '0' && c <= '9')
        return c - '0';

    if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;

    if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    return -1;
}
/* Returns the character designation of a number using the ASCII table. */
char ValueToChar(int value) {
    if (value >= 0 && value <= 9)
        return (char)('0' + value);

    return (char)('a' + (value - 10));
}



/* Returns a list of characters that are valid in the given number system. */
char* AcceptableSymbols(int base) {
    char *listofcharacters = malloc((base  + 2)* sizeof(char));

    if (listofcharacters == NULL)
        return NULL;

    for (int i = 0; i < base; i++)
        *(listofcharacters + i) = ValueToChar(i);
    *(listofcharacters + base) = '.';
    *(listofcharacters + base + 1) = '\0';
    return listofcharacters;
}

/* checks that all characters in the number satisfy the given number system  и делает все проверки на правильность числа */
int ValideteNumber(const char *number, int base, int len) {
    char *list = AcceptableSymbols(base);

    if (len > 13 || *number == '.' || *(number + len - 1) == '.') {
        free(list);
        return 0;
    }
    int point = 0;

    for (int i = 0; i < len; i++)
        if (*(number + i) == '.') {
            point++;
            if (point > 1) {
                free(list);
                return 0;
            }
        }

    for (int i = 0; i < len; i++) {
        int validcharacter = 0;

        for (int j = 0; *(list + j) != '\0'; j++)
            if (*(number + i) == *(list + j)) {
                validcharacter = 1;
                break;
            }

        if (validcharacter == 0) {
            free(list);
            return 0;
        }
    }
    if (point == 0 && *number == '0' && len != 1){
    free(list);
    return 0;
}
    if (point == 1 && *number == '0' && *(number + 1) == '0') {
        free(list);
        return 0;
    }
    free(list);
    return 1;
}

void SplitNumberString(const char* number, char* integerpart, char* fractionalpart) {
    int point = 0, pointindex = 0, lastintindex = 0, lastfractionalindex = 0;
    for (int i = 0; *(number + i) != '\0'; i++) {

        if (*(number + i) == '.')
            point++;

        if (point == 0) {
            pointindex++;
            *(integerpart + i) = *(number + i);
            lastintindex = i;
        }
        else if (*(number + i) != '.') {
            *(fractionalpart + i - 1 - pointindex) = *(number + i);
            lastfractionalindex = i - 1 - pointindex;
        }
    }
    *(integerpart + lastintindex + 1) = '\0';
    *(fractionalpart + lastfractionalindex + 1) = '\0';
}

/* The Gorner algorithm */
int IntStringToDecimal(const char* integerpart, int base) {
    int result = 0;
    for (int i = 0; *(integerpart + i) != '\0'; i++)
        result = result * base + CharToValue(*(integerpart + i));
    return result;
}

double FracStringToDecimal(const char* fractionalpart, int base, int len) {
    double result = 0;
    for (int i = len - 1; i >= 0; i--)
        result = (result + CharToValue(*(fractionalpart + i))) / base;
    return result;
}

double StringToDecimal(const char* number, int base) {
    char* integerpart = malloc(sizeof(char) * 14); //проверка выделения памяти
    char* fractionalpart = malloc(sizeof(char) * 14); //проверка выделения памяти

    *(integerpart + 13) = '\0';
    *(fractionalpart + 13) = '\0';

    SplitNumberString(number, integerpart, fractionalpart);

    double result = IntStringToDecimal(integerpart, base) + FracStringToDecimal(fractionalpart, base, (int)strlen(fractionalpart));

    free(integerpart);
    free(fractionalpart);

    return result;
}
/* Converts an integer from decimal to a certain number system. */
char* IntDecimalToString(int number, int base) {
    if (number == 0) {
        char *res = malloc(2 * sizeof(char)); //проверка выделения памяти
        *res = '0';
        *(res + 1) = '\0';
        return res;
    }

    int lenres = 0;
    int copynum = number;

    /* Defines the length of the converted number. */
    while (copynum > 0) {
        lenres++;
        copynum /= base;
    }

    char *res = malloc((lenres + 1)  * sizeof(char)); //проверка выделения памяти
    *(res + lenres) = '\0';

    /* Fills an array with characters in reverse order. */
    int i = lenres - 1;
    while (number > 0) {
        char character = ValueToChar(number % base);
        *(res + i) = character;
        number /= base;
        i--;
    }

    return res;
}

/* Converts the fractional part of a number from decimal to a certain number
 * system. Multiplies the fractional part by the base of the number system.
 * The character designation of the integer part of the resulting number
 * is the first digit after the decimal point of the converted number.
 * The fractional remainder is then converted in a similar manner. */
char* FloatDecimalToString(double number, int base) {
    int singsafterdot = 0;
    char *res = malloc(14 * sizeof(char)); //проверка выделения памяти

    /* Needs to get the first 12 digits after decimal point */
    while (singsafterdot < 12) {
        char character = ValueToChar((int)(number * base));
        *(res + singsafterdot) = character;

        singsafterdot ++;
        number = (number * base) - (int)(number * base);

        /* Returns the result earlier if there are fewer than 12 digits after
         * the decimal point.*/
        if (number == (int)number) {
            *(res + singsafterdot) = '\0';
            return res;
        }
    }
    *(res + singsafterdot) = '\0';
    return res;
}

//если целое, то просто вывод числа
//если дробное, то в зависимости от количества набранных символов
char* DecimalToString(double num, int base) {
    if (num == (int)num) {
        char* result = IntDecimalToString((int)num, base);
        return result;
    }
    int integerpart = (int)num;
    double fractionalpart = num - integerpart;
    char* convintpart = IntDecimalToString(integerpart, base);
    char* convfracpart = FloatDecimalToString(fractionalpart, base);
    char* result = malloc((strlen(convfracpart) + strlen(convintpart) + 1) * sizeof(char));
    int pointindex = 0;
    for (int i = 0; i < strlen(convintpart); i++) {
        *(result + i) = *(convintpart + i);
        pointindex = i + 1;
    }
    *(result + pointindex) = '.';
    int j = 0;
    for (int i = pointindex + 1; i <= pointindex + strlen(convfracpart); i++) {
        *(result + i) = *(convfracpart + j);
        j++;
    }
    *(result + pointindex + strlen(convfracpart) + 1) = '\0';
    free(convfracpart);
    free(convintpart);
    return result;
}

